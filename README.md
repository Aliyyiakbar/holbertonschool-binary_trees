# Holberton School – Binary Trees

This repository contains our C solutions for the **Holberton School – Binary Trees** project.
It focuses on understanding binary trees from the basics (creating nodes, traversals, tree
properties) up to advanced structures like **BST**, **AVL**, and **Max Binary Heap**.

## Requirements

- OS: Ubuntu 20.04 LTS
- Compiler: `gcc`
- Flags: `-Wall -Werror -Wextra -pedantic -std=gnu89`
- Style: Betty
- No global variables
- Max 5 functions per file
- All files end with a new line
- Header: `binary_trees.h` (include-guarded, contains all prototypes)

## Tasks

### Basic Binary Tree (0–23)
- **0. New node** — create a new binary tree node
- **1. Insert left** — insert a node as the left child of another node
- **2. Insert right** — insert a node as the right child of another node
- **3. Delete** — delete an entire binary tree
- **4. Is leaf** — check if a node is a leaf (no children)
- **5. Is root** — check if a node is the root (no parent)
- **6. Pre-order traversal** — visit nodes: root → left → right
- **7. In-order traversal** — visit nodes: left → root → right
- **8. Post-order traversal** — visit nodes: left → right → root
- **9. Height** — measure the height of a tree
- **10. Depth** — measure the depth of a node
- **11. Size** — count total number of nodes
- **12. Leaves** — count the number of leaf nodes
- **13. Nodes** — count nodes with at least one child
- **14. Balance factor** — calculate balance factor of a node
- **15. Is full** — check if every node has 0 or 2 children
- **16. Is perfect** — check if tree is full and all leaves are at same level
- **17. Sibling** — find a node’s sibling
- **18. Uncle** — find a node’s uncle
- **19. Lowest common ancestor** — find the closest shared ancestor of two nodes
- **20. Level-order traversal** — traverse nodes level by level (BFS)
- **21. Is complete** — check if tree is complete
- **22. Rotate left** — perform a left rotation on a subtree
- **23. Rotate right** — perform a right rotation on a subtree

### Binary Search Tree (24–30)
- **24. Is BST** — check if a tree follows BST rules
- **25. BST insert** — insert a value into a BST
- **26. Array to BST** — build a BST from an array
- **27. BST search** — search for a value in a BST
- **28. Big O #BST** — write time complexity for BST operations
- **29. BST remove** — remove a node from a BST
- **30. Big O #BST** — write time complexity for BST remove

### AVL Tree (31–36)
- **31. Is AVL** — check if a tree is a valid AVL tree
- **32. AVL insert** — insert a value into an AVL tree (with rebalancing)
- **33. Array to AVL** — build an AVL tree from an array
- **34. AVL remove** — remove a node from an AVL tree (with rebalancing)
- **35. AVL from sorted array** — build a balanced AVL from sorted array
- **36. Big O #AVL** — write time complexity for AVL operations

### Max Binary Heap (37–43)
- **37. Is Binary heap** — check if a tree is a valid max heap
- **38. Heap insert** — insert a value into a max heap
- **39. Array to heap** — build a max heap from an array
- **40. Heap extract** — remove and return the root value
- **41. Heap sort** — sort an array using heap operations
- **42. Big O #Binary Heap** — write time complexity for heap operations
- **43. Big O #Binary Heap** — write time complexity for heap extract/sort

## Authors

Aliyyiakbar Shirinli  
Celal Ehmedli
